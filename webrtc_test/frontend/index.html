<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Test</title>
</head>
<body>
    <h1>WebRTC Video Stream Test</h1>
    <video id="remoteVideo" autoplay playsinline></video>
    <script>
        /*
          states to watch:
          pc.onicecandidate
          pc.onicecandidateerror
          pc.onicecandidatestatechange
          pc.onicegatheringstatechange
          pc.onconnectionstatechange
          pc.ondatachannel
          pc.onnegotiationneeded
          pc.onsignalingstatechange
          pc.ontrack
        */

        const offerAnswerStatus = {
            offerSent: false,
            answerReceived: false,
        };

        const configuration = {
            "iceServers": [], // No STUN or TURN servers
            "iceTransportPolicy": "all"
        };

        const iceCandidates = [];

        // Utility Functions

        // FIXME: Broken 
        function prettyPrintSDP(data, action) {
          console.log(`--- DATA START --- `);
          console.log(`--- TYPE: ${action} --- `);
          if (action == "ice_candidates") {
            console.log(data);
          } else if (action == "sdp") {
              data.split('\r\n').forEach((line) => {
                  if (line.trim() !== '') {
                      console.log(line);
                  }
              });
          } else {
            console.log("Invalid data access: Options are 'sdp' or 'ice_candidates'")
          }
          console.log('--- DATA START ---');
        }

        function waitForIceGatheringComplete(pc) {
            return new Promise((resolve) => {
                if (pc.iceGatheringState === "complete") {
                    resolve();
                } else {
                    const checkState = () => {
                        if (pc.iceGatheringState === "complete") {
                            pc.removeEventListener("icegatheringstatechange", checkState);
                            resolve();
                        }
                    };
                    pc.addEventListener("icegatheringstatechange", checkState);
                }
            });
        }

        const pc = new RTCPeerConnection(configuration);
        const signalingUrl = 'http://localhost:8080';
        const videoElement = document.getElementById('remoteVideo');

        // Handle incoming video stream
        pc.ontrack = (event) => {
            if (event.streams && event.streams[0]) {
                videoElement.srcObject = event.streams[0];
            }
        };

        pc.onicecandidate = (event) => {
          if (event.candidate) {
              console.log(`Generated ICE Candidate: ${event.candidate}`);
              console.log(`Generated ICE Candidate IP: ${event.candidate.candidate.split(" ")[4]}`);
              iceCandidates.push(event.candidate); // Add the candidate to the list
          } else {
              console.log("All ICE candidates have been gathered for offer.");
          }
        }

        async function sendOffer() {
            if (!offerAnswerStatus.offerSent) {
                pc.addTransceiver('video', { direction: 'recvonly' });

                // Create the offer and set as local description
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                // Wait for ICE gathering to complete
                await waitForIceGatheringComplete(pc);

                // Send offer to signaling server
                await fetch(`${signalingUrl}/frontend/offer`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        offer: { sdp: pc.localDescription.sdp, type: pc.localDescription.type },
                        ice_candidates: iceCandidates.map(candidate => ({
                            candidate: candidate.candidate,
                            sdpMid: candidate.sdpMid,
                            sdpMLineIndex: candidate.sdpMLineIndex
                        }))
                    })
                });

                console.log(`Frontend: Offer sent to signaling server.`);
                offerAnswerStatus.offerSent = true;
            }
           // TODO: return??
        }

        async function getAnswer() {
            console.log("RemoteCandidate: ", pc.iceGatheringState)
            if (!offerAnswerStatus.answerReceived) {
                const response = await fetch(`${signalingUrl}/frontend/answer`);
                if (response.ok) {
                    const data = await response.json();
                    console.log(`Frontend: Answer received: ${data.answer}`);

                    // Set the remote description with the received answer
                    await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                    console.log(`Frontend: RemoteDescription added answer`);

                    
                    // FIXME: Create a loop to add all remote candidates
                    await pc.addIceCandidate(new RTCIceCandidate(data.ice_candidates[0]));
                    console.log(`Frontend: Added ICE candidate: ${data.ice_candidates[0]}`);

                    offerAnswerStatus.answerReceived = true;
                } else {
                    console.log("Frontend: No answer available yet.");
                }
            }
            //TODO: return ??
        }

        async function startWebRTC() {
            // TODO: Add conditional here to stop running this upon getting the answer back from peer.
            await sendOffer();
            await getAnswer();

            // Periodically check for an answer if not yet received
            const answerCheckInterval = setInterval(async () => {
                if (!offerAnswerStatus.answerReceived) {
                    await getAnswer();
                } else {
                    clearInterval(answerCheckInterval);
                }
            }, 5000);

            // TODO: On what state should I set remote and ice_candidates from remote???

            // Track connection state changes
            pc.onconnectionstatechange = () => {
                console.log('Connection State: ', pc.connectionState);
                console.log('Current Local Description:', pc.currentLocalDescription);
                console.log('Current Remote Description :', pc.currentRemoteDescription);
                console.log('Signaling State:', pc.signalingState);
            };

            // Track ICE connection state changes
            pc.oniceconnectionstatechange = () => {
                console.log('ICE Connection State:', pc.iceConnectionState);
            };

            addEventListener('icecandidaterror', (event) => {});
            pc.onicecandidateerror = (event) => {
                console.log('ICE candidate error:', event);
          }
        }

        // Start the WebRTC process
        startWebRTC();
    </script>
</body>
</html>

